//
// Created by dingjing on 23-10-10.
//

#include "vulnerability-report.h"

#include <glib.h>

#include <QDebug>
#include <QApplication>

#include "log.h"
#include "global.h"
#include "utils/tools.h"

VulnerabilityReport* VulnerabilityReport::gInstance = nullptr;

VulnerabilityReport *VulnerabilityReport::getInstance()
{
    static gsize ii = 0;
    if (g_once_init_enter(&ii)) {
        if (!gInstance) {
            gInstance = new VulnerabilityReport();
            g_once_init_leave(&ii, 1);
        }
    }
    return gInstance;
}


void VulnerabilityReport::reset()
{
    mLocker.lock();

    mData.clear();
    mDataIdx.clear();

    mLocker.unlock();
}

VulnerabilityReport::VulnerabilityReport(QObject *parent)
    : QObject (parent), mDBPath(gDBPath), mPause (0)
{
    mTimer = new QTimer;
    mTimer->setInterval (3);

    connect (mTimer, &QTimer::timeout, this, [=] () -> void {
        if (mIsRunning > 0) return;
        onDBChanged();
    });

    connect (this, &VulnerabilityReport::start, this, [&] () -> void {
        mPause = 0;
        mTimer->start();
    });

    connect (this, &VulnerabilityReport::pause, this, [&] () {
        mPause = 1;
    });

    connect (this, &VulnerabilityReport::stop, this, [&] () -> void {
        mPause = 2;
        mTimer->stop();
    });
}

void VulnerabilityReport::closeSqlite()
{
    if (mDB) {
        sqlite3_close (mDB);
        mDB = nullptr;
    }
}

bool VulnerabilityReport::openSqlite()
{
    closeSqlite();

    int rc = sqlite3_open (mDBPath.toUtf8().constData(), &mDB);
    if (SQLITE_OK != rc) {
        qWarning() << "connect to db: " << mDBPath << " failed!";
        return false;
    }

    return true;
}

void VulnerabilityReport::onDBChanged()
{
    if (mPause > 0) return;

    QString sql ("SELECT vuln_name, vuln_num, descript, issue_date, url FROM vulnerability_report;");
    LOG_DEBUG("sql: %s", sql.toUtf8().constData());
    {
        if (!openSqlite()) return;
        {
            TaskDBLock lock;
            lock.lock ();
            sqlite3_stmt *stmt = nullptr;
            qDebug () << sql;
            int ret = sqlite3_prepare_v2 (mDB, sql.toUtf8 ().constData (), -1, &stmt, nullptr);
            if (SQLITE_OK == ret) {
                while (SQLITE_DONE != sqlite3_step (stmt)) {
                    QApplication::processEvents ();

                    QString name (reinterpret_cast<const char *> (sqlite3_column_text (stmt, 0)));
                    QString num (reinterpret_cast<const char *> (sqlite3_column_text (stmt, 1)));
                    QString desc (reinterpret_cast<const char *> (sqlite3_column_text (stmt, 2)));
                    QString date (reinterpret_cast<const char *> (sqlite3_column_text (stmt, 3)));
                    QString url (reinterpret_cast<const char *> (sqlite3_column_text (stmt, 4)));

                    if (nullptr == name || name.isEmpty ()) {
                        continue;
                    }

                    mLocker.lock ();
                    if (!mDataIdx.contains (name)) {
                        auto it = std::make_shared<VulnerabilityItem> (name, name, desc, date, url);
                        mData.append (it);
                        mDataIdx[name] = it;
                        Q_EMIT addItem(name);
                    }
                    mLocker.unlock ();
                }
                sqlite3_finalize (stmt);
            } else {
                qWarning () << "query db error!";
            }
        }
    }
}

std::shared_ptr<VulnerabilityItem> VulnerabilityReport::getItemByKey(QString &name)
{
    if (mDataIdx.contains (name)) {
        return mDataIdx[name];
    }

    return nullptr;
}
