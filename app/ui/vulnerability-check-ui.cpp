//
// Created by dingjing on 23-10-10.
//

#include "vulnerability-check-ui.h"

#include <QLabel>
#include <QDebug>
#include <QScrollBar>
#include <QScrollArea>
#include <QPushButton>
#include <QApplication>

#include "utils/process.h"
#include "common/global.h"
#include "db/vulnerability-report.h"

#define SOFTWARE_TITLE              "漏洞检查 ----------------------------------------------------------------------- %1项"

VulnerabilityCheckUI::VulnerabilityCheckUI(Type type, QWidget *parent)
    : QWidget (parent), mIsChecked(false), mType(type)
{
    mProgress = new Process(this);
    mMainLayout = new QVBoxLayout;
    auto titleLayout = new QHBoxLayout;

    mProgress->setCommand(gVulnerabilityScannerPath);

    mTitle = new QLabel;
    titleLayout->addWidget (mTitle);

    auto f = qApp->font();
    f.setPointSizeF (f.pointSizeF() - 2);
    QFontMetrics fm(f);
    static const int pSize = fm.width (SOFTWARE_TITLE);
    mTitle->setMinimumWidth (pSize + 100);

    mShowDetail = new QPushButton;
    mShowDetail->setFlat (true);
    titleLayout->addWidget (mShowDetail);
    titleLayout->addStretch ();

    mMainLayout->addLayout (titleLayout);

    mDetailWidget = new QWidget;    // top
    auto detailLayout = new QVBoxLayout;
    mDetailWidget->setFixedHeight(360);
    mDetailWidget->setSizePolicy (QSizePolicy::Expanding, QSizePolicy::Expanding);

    auto scrollArea = new QScrollArea;
    scrollArea->setWidgetResizable (true);
    scrollArea->setSizePolicy (QSizePolicy::Expanding, QSizePolicy::Expanding);

    auto scrollWidget = new QWidget; // in
    scrollWidget->setSizePolicy (QSizePolicy::Expanding, QSizePolicy::Expanding);

    auto scrollLayout = new QVBoxLayout;

    scrollWidget->setLayout (scrollLayout);
    scrollArea->setWidget (scrollWidget);

    detailLayout->addWidget (scrollArea);
    mDetailWidget->setLayout (detailLayout);

    mMainLayout->addWidget (mDetailWidget);

    setLayout (mMainLayout);

    connect (mProgress, &Process::finished, this, [=] (int extCode) {
        qDebug() << "退出--> " << extCode;
    });

    connect (this, &VulnerabilityCheckUI::stop, this, [=] () -> void {
        VulnerabilityReport::getInstance()->stop();
        Q_EMIT reset();
    });

    connect (this, &VulnerabilityCheckUI::pause, this, [=] () -> void {
        VulnerabilityReport::getInstance()->pause();
    });

    connect (this, &VulnerabilityCheckUI::start, this, [=] (bool start) -> void {
        mProgress->start();
        while (!mProgress->isFinished()) {
            QApplication::processEvents ();
        };
        if (start) {
            VulnerabilityReport::getInstance()->start();
        }
    });

    auto scrollBar = scrollArea->verticalScrollBar();
    scrollBar->setMinimum (0);
    connect (scrollBar, &QScrollBar::valueChanged, this, [=] (int value) {
        if (mShowedItem <= value) {
            lazyUpdate (value);
        }
    });

    connect (this, &VulnerabilityCheckUI::lazyUpdate, this, [=] (int c) -> void {
        if (0 == c) {
            if (mShowedItem > 0) return;
            else {
                int size = ((mItemWidget.size() > 10) ? 10 : mItemWidget.size());
                for (int i = 0; i < size; ++i) {
                    scrollLayout->addWidget (mItemWidget[i].get());
                }
            }
        }
        else {
            int size = ((mItemWidget.size() > (c + 10)) ? (c + 10) : mItemWidget.size());
            for (int i = mShowedItem; i < size; ++i) {
                scrollLayout->addWidget (mItemWidget[i].get());
            }
        }

    });

    connect (this, &VulnerabilityCheckUI::addItem, this, [=] (const std::shared_ptr<VulnerabilityItem>& item) -> void {
        if (mType == Success) {
            ++mSuccessItem;
            Q_EMIT updateItemCount (mSuccessItem);
        }
        else if (mType == Warning) {
            // 都没有问题
//            ++mWarningItem;
//            Q_EMIT updateItemCount (mWarningItem);
        }

        auto itemUI = std::make_shared<VulnerabilityCheckItemUI>(
            item->getName(),
            item->getNameNumber(),
            /*item->getDesc()*/"",
            item->getDate(),
            item->getUrl());
        mItemWidget.append (itemUI);
        scrollBar->setMaximum (mItemWidget.size());
//        detailLayout->addWidget (itemUI.get());
    });

    connect (this, &VulnerabilityCheckUI::reset, this, [=] () -> void {
        VulnerabilityReport::getInstance()->reset();
        for (auto& i : mItemWidget) {
            // FIXME://
//            detailLayout->removeWidget (i.get());
        }
        mSuccessItem = 0;
        mWarningItem = 0;
        mItemWidget.clear();

        Q_EMIT updateItemCount ();
    });

    connect (this, &VulnerabilityCheckUI::updateItemCount, this, [=] (int count) {
        mTitle->setText (QString(SOFTWARE_TITLE).arg (count));
    });

    connect (mShowDetail, &QPushButton::clicked, this, [=] (bool) {
        mIsChecked = !mIsChecked;
        mShowDetail->toggled (mIsChecked);
    });
    connect (mShowDetail, &QPushButton::toggled, this, [=] (bool checked) {
        QPixmap pix((!checked ? ":/data/down.png" : ":/data/up.png"));
        mShowDetail->setIcon (pix);
        if (checked) {
            mDetailWidget->show();
            lazyUpdate ();
        }
        else {
            mDetailWidget->hide();
        }
        Q_EMIT resizeUI();
    });

    Q_EMIT updateItemCount ();
    Q_EMIT mShowDetail->toggled (mIsChecked);
}

int VulnerabilityCheckUI::getSuccessItem() const
{
    return ((mSuccessItem > 0) ? mSuccessItem : 0);
}

int VulnerabilityCheckUI::getWarningItem() const
{
    return ((mWarningItem > 0) ? mWarningItem : 0);
}



